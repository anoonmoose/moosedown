<Query Kind="Program" />

/*
you're going to need to supply these two constants yourself
better make sure they're correct, there's no error handling

from my very basic testing, linqpad will choke on the 403 and 400 errors
generated by screwing up those two things, and the worst case scenarios 
are that you pour junk into your database or get your api key revoked
*/

const string USER_NAME = ;
const string API_KEY = ;

//this program will either build a new database or update an existing one
void Main()
{
	if (Listens.Count() == 0) { BuildDB(); }
	else { UpdateDB(); }
}

//builds a local copy of a lastfm database from scratch
void BuildDB()
{
	var cnt = Convert.ToInt32(Math.Ceiling(GetPlayCount() / 200.0));//get page count
	for (int i = 1; i <= cnt; i++)//get every page
	{
		var dx = GetPage(i);
		var tStart = DateTime.Now;//time after downloading page
		foreach (var d in dx) { Listens.InsertOnSubmit(d); }//insert tracks
		if (i % 50 == 0) { SubmitChanges(); }//submit every 50 pages
		var delta = (DateTime.Now - tStart).TotalMilliseconds;//calculate time to insert
		if (delta < 250) { Thread.Sleep(250 - (int)delta); }//limit to 4 reqs per second
		Console.WriteLine("page " + i + " took " + delta + " ms");//output to user
	}
	SubmitChanges();//submit any remaining inserts
	Console.WriteLine(Listens.Count().ToString() + " total");//output to user
}

//updates an existing local copy of a lastfm database
void UpdateDB()
{
	var OldCount = Listens.Count();
	var PlayCount = GetPlayCount();
	if (OldCount == PlayCount) { "no new tracks".Dump(); return; }//if we have every track, stop

	var cnt = Convert.ToInt32(Math.Ceiling(PlayCount / 200.0));//get page count
	bool kl = false;//state variable, tells us when we hit the end
	var lTime = Listens.OrderByDescending(x => x.Utime).First().Utime;//last timestamp in current db

	for (int i = 1; i <= cnt && !kl; i++)//keep going until we hit the end or last timestamp
	{
		var dx = GetPage(i).Where(x => x.Utime > lTime);//every track later than our last timestamp
		var tStart = DateTime.Now;//time after download
		if (dx.Count() != 200) { kl = true; }//if all tracks in page aren't needed, this is last page
		foreach (var d in dx) { Listens.InsertOnSubmit(d); }//insert all tracks
		SubmitChanges();//submit after every page, assumes we have a small number of pages to update
		var delta = (DateTime.Now - tStart).TotalMilliseconds;//calculate time since last page download
		if (delta < 250) { Thread.Sleep(250 - (int)delta); }//limit to 4 reqs per second
		Console.WriteLine("save page " + i + " took " + delta + " ms");//output to user
	}
	Console.WriteLine("added " + (Listens.Count() - OldCount) + " tracks");//output to user
}

//using the api to grab page i of user.getrecenttracks
List<Listen> GetPage(int i)
{
	//build url for api request
	var rt = "http://ws.audioscrobbler.com/2.0/";//root
	var mt = "?method=user.getrecenttracks&user=" + USER_NAME;//most of command
	mt += "&extended=0&limit=200&page=" + i.ToString();//rest of command
	var api = "&api_key=" + API_KEY;//key for command
	var mess = rt + mt + api;
	var wq = System.Net.WebRequest.CreateHttp(mess);
	var str = wq.GetResponse().GetResponseStream();
	var sw = new StreamReader(str).ReadToEnd();
	var root = XElement.Parse(sw);
	var dt = new List<Listen>();
	//not gonna lie, this is ugly and fragile, i'm bad at xml
	var tx = root.Element("recenttracks").Elements("track");
	foreach (var t in tx)
	{
		var np = t.Attributes().Where(x => x.Name == "nowplaying");
		if (np.Count() == 0)
		{
			dt.Add(GetTrack(t));
		}
	}
	return dt;
}

//parses xml of a track for the relevant data
Listen GetTrack(XElement t)
{
	var qx = new Listen();
	//not gonna lie, this is ugly and fragile, i'm bad at xml
	qx.Utime = Int64.Parse(t.Element("date").Attribute("uts").Value);
	qx.Ltime = DateTimeOffset.FromUnixTimeSeconds(qx.Utime).ToLocalTime().DateTime;
	qx.Artist = t.Element("artist").Value;
	qx.Armbid = t.Element("artist").Attribute("mbid").Value;
	qx.Album = t.Element("album").Value;
	qx.Almbid = t.Element("album").Attribute("mbid").Value;
	qx.Song = t.Element("name").Value;
	qx.Sombid = t.Element("mbid").Value;
	return qx;
}

//using the api to grab the user.getinfo element playcount
long GetPlayCount()
{
	var rt = "http://ws.audioscrobbler.com/2.0/";
	var mt = "?method=user.getinfo&user=" + USER_NAME;
	var api = "&api_key=" + API_KEY;
	var mess = rt + mt + api;
	var wq = System.Net.WebRequest.CreateHttp(mess);
	var str = wq.GetResponse().GetResponseStream();
	var sw = new StreamReader(str).ReadToEnd();
	var root = XElement.Parse(sw);
	Thread.Sleep(250);//limit to 4 reqs per second
	//ugly and fragile, i'm bad at xml
	return Int64.Parse(root.Element("user").Element("playcount").Value);
}